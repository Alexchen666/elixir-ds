<!-- livebook:{"autosave_interval_s":600,"file_entries":[{"name":"car_data_cleaned.csv","type":"attachment"}]} -->

# Car Data Analysis

```elixir
Mix.install([
  {:explorer, "~> 0.11.1"},
  {:kino_vega_lite, "~> 0.1.11"},
  {:scholar, "~> 0.4.1"},
  {:nx, "~> 0.10.0"}
])
```

## 1. Introduction

In this project, I will determine what influences and drives the car prices (MSRP, Manufacturerâ€™s Suggested Retail Price) given its technical specs. Specifically, I will demonstrate which car(s) is/are the most under/overpriced one(s).

The target variable is continuous, so it is reasonable to use regression models. Besides, in this case, I focus on the factors influencing car prices, so interpretability is important. In the project, I will perform data cleaning and preliminary data visualisation first, fit several base models with good interpretability, conduct hyperparameter tuning, interpret the model, and explain some cases from the prediction as well as demonstrate the cars I believe to be most under/overpriced. In the end, I will further discuss the effect of the brand.

All the assumptions I took in the project:

> The effect of the brand is small so I don't have to include the variable related to the brand.
> 
> The imputation method is robust.
> 
> Except for the variables in the dataset, there are no other variables determining the price of a car, including promotion, and pricing strategy.

```elixir
require Explorer.DataFrame, as: DF
require Explorer.Series, as: S
require Explorer.Query, as: Q
```

```elixir
df = DF.from_csv!("~/SideProjects/elixir-ds/car_data_cleaned.csv")
```

```elixir
df |> DF.head()
```

```elixir
df |> DF.n_columns()
```

```elixir
df |> DF.n_rows()
```

## 2. Data Cleaning

In this section, I will work on several things,

* Drop the unnecessary columns
* Tidy the categorical variables
* Set the correct data types

Among all featuers, it is difficult to know the meaning of `Other Features`, so I worked on this first.

```elixir
df 
  |> DF.pull("Other Features")
  |> Explorer.Series.split("\r\n") 
  |> Explorer.Series.to_list()
  |> List.flatten()
  |> Enum.frequencies()
  |> Enum.to_list()
  |> Enum.sort_by(&elem(&1, 1), :desc)
  |> Enum.take(20)
```

Many common `Other Features` are overlapped with the other variables in the model, such as the features related to airbags, child safety rear door locks, ABS, stability control, back-up camera, tire pressure monitor, parking aid, and so on. So to simplify the data, I will drop this column.

Given different data types, the methods of preprocessing are different. The list below is the methods summary I will use to process the data after checking the data.

Consider all variables,

### Response Variable

* MSRP: the response variable, only keep the data without NA

### Unnecessary Variables (Drop the Variables)

> Assumption:
> 
> In this project, I only looked at the technical specs, hence I assumed that the effect of the brand is small and I don't have to include the variable related to the brand.

* Car_Make_Model_Style: do not consider (assumption), drop
* Style Name: do not consider (assumption), drop
* EPA Classification: because it is similar to Body Style and contains lots of NA values, I dropped this one and keep Body Style instead
* Basic Miles/km: not related to technical specs, drop
* Basic Years: not related to technical specs, drop
* Corrosion Miles/km: not related to technical specs, drop
* Corrosion Years: not related to technical specs, drop
* Drivetrain Miles/km: not related to technical specs, drop
* Drivetrain Years: not related to technical specs, drop
* Roadside Assistance Miles/km: not related to technical specs, drop
* Roadside Assistance Years: not related to technical specs, drop
* Other Features: duplicated with other columns, to drop
* Categorical Variables (Set to Categorical Variables)
* Drivetrain: to categorical
* Body Style: to categorical
* Air Bag-Frontal-Driver: to categorical
* Air Bag-Frontal-Passenger: to categorical
* Air Bag-Passenger Switch (On/Off): to categorical
* Air Bag-Side Body-Front: to categorical
* Air Bag-Side Body-Rear: to categorical
* Air Bag-Side Head-Front: to categorical
* Air Bag-Side Head-Rear: to categorical
* Brakes-ABS: to categorical
* Child Safety Rear Door Locks: to categorical
* Daytime Running Lights: to categorical
* Traction Control: to categorical
* Night Vision: to categorical
* Rollover Protection Bars: to categorical
* Fog Lamps: to categorical
* Parking Aid: to categorical
* Tire Pressure Monitor: to categorical
* Back-Up Camera: to categorical
* Stability Control: to categorical
* Engine Configuration: to categorical
* Engine Class: to categorical
* Year: to categorical
* Categorical Variables (Simplify the Categories and Set to Categorical Variables)
* Fuel System: some duplicated types, need to be cleaned
* Steering Type: some duplicated types, need to be cleaned
* Suspension Type - Front: some duplicated types, need to be cleaned
* Suspension Type - Rear: some duplicated types, need to be cleaned
* Numerical Variables (Keep Original)
* Passenger Capacity
* Passenger Doors
* Base Curb Weight (lbs)
* Front Hip Room (in)
* Front Leg Room (in)
* Second Shoulder Room (in)
* Passenger Volume
* Second Head Room (in)
* Front Shoulder Room (in)
* Second Hip Room (in)
* Front Head Room (in)
* Second Leg Room (in)
* Wheelbase (in)
* Track Width, Front (in)
* Width, Max w/o mirrors (in)
* Track Width, Rear (in)
* Height, Overall (in)
* Fuel Tank Capacity, Approx (gal)
* Fuel Economy Est-Combined (MPG)
* EPA Fuel Economy Est - City (MPG)
* EPA Fuel Economy Est - Hwy (MPG)
* First Gear Ratio (:1)
* Fourth Gear Ratio (:1)
* Second Gear Ratio (:1)
* Reverse Ratio (:1)
* Fifth Gear Ratio (:1)
* Trans Type
* Third Gear Ratio (:1)
* Final Drive Axle Ratio (:1)
* Turning Diameter - Curb to Curb
* Front Wheel Material
* Maximum Alternator Capacity (amps)
* Gears
* Net Horsepower
* Net Horsepower RPM
* Net Torque
* Net Torque RPM
* Displacement (L)
* Displacement (cc)
* Rear Tire Width
* Front Tire Width
* Rear Wheel Size
* Front Wheel Size
* Tire Width Ratio
* Wheel Size Ratio
* Tire Ratio

```elixir
df1 = df |> DF.discard(["Car_Make_Model_Style", 
  "Style Name", "EPA Classification", "Other Features",
  "Basic Miles/km", "Basic Years", "Corrosion Miles/km", "Corrosion Years",
  "Drivetrain Miles/km", "Drivetrain Years", "Roadside Assistance Miles/km" ,
  "Roadside Assistance Years", ""]) # drop the unnecessary variables
    |> DF.drop_nil("MSRP") # drop the data with NA values in MSRP
```

```elixir
# check the unique values for the variables which needing to be simplified
df1 |> DF.select(["Fuel System", "Steering Type", "Suspension Type - Front", 
  "Suspension Type - Rear"]) 
  |> DF.to_series() 
  |> Enum.map(fn {k, v} -> {k, Explorer.Series.distinct(v)} end)
```

To simplify the categories for these four variables, I refered the data below,

[1] Fuel System: https://autoportal.com/articles/what-is-gdi-fsi-cgi-sidi-direct-injection-6965.html

[2] Steering Type: https://steeringly.com/rack-and-pinion-system-vs-power-steering-system-what-are-the-differences/

[3] Suspension Type: https://www.caranddriver.com/news/a15340751/explained-the-five-most-common-automotive-suspensions/

```elixir
fuel_system_map = fn c ->
  case c do
    "Sequential MPI (injection)" -> "Sequential MPI"
    "Gasoline Direct Injection" -> "DI"
    "Diesel Direct Injection" -> "DI"
    "Direct Injection" -> "DI"
    _ -> c
  end
end

steering_type_map = fn c ->
  case c do
    "Rack-Pinion" -> "Rack & Pinion"
    "Electric Rack-&-Pinion" -> "Electric Rack & Pinion"
    "4-Wheel Pwr Rack & Pinion" -> "Pwr Rack & Pinion"
    "Electric Variable-Effort Power" -> "Electric Pwr Steering"
    "Electric Power Steering" -> "Electric Pwr Steering"
    "Electric Pwr" -> "Electric Pwr Steering"
    "Pwr Rack-&-Pinion" -> "Pwr Rack & Pinion"
    "Pwr Electric Assist" -> "Electric Pwr Steering"
    _ -> c
  end
end

suspension_front_map = fn c ->
  case c do
    "Double Wishbone Pushrod" -> "Double Wishbone"
    "Independent MacPherson Strut" -> "MacPherson Strut"
    "HiPer strut" -> "HiPer Strut"
    "MacPherson strut" -> "MacPherson Strut"
    "HiPER strut" -> "HiPer Strut"
    "Independent SLA" -> "Short/Long Arm"
    "Coil springs" -> "Coil Spring"
    "Short And Long Arm" -> "Short/Long Arm"
    "Coil Over Strut" -> "Coil-Over Strut"
    "Coil-Over Shock" -> "Coil-Over Strut"
    _ -> c
  end
end

suspension_rear_map = fn c ->
  case c do
    "5-link" -> "Multi-Link"
    "4-Link" -> "Multi-Link"
    "5-Link" -> "Multi-Link"
    "Four-Link Independent" -> "Multi-Link"
    "Five-Link" -> "Multi-Link"
    "Independent Multi-Link" -> "Multi-Link"
    "Independent multi-link" -> "Multi-Link"
    "Independent Five-Link" -> "Multi-Link"
    "Five-Link Independent" -> "Multi-Link"
    "Four-Link" -> "Multi-Link"
    "Multi link" -> "Multi-Link"
    "Independent" -> "Multi-Link"
    "Multi-link" -> "Multi-Link"
    "Linked H-arm" -> "H-Arm"
    "Linked H-Arm" -> "H-Arm"
    "2-Stage Multi-Leaf" -> "Multi-Leaf"
    "Z-Link Compound Crank" -> "Compound Crank"
    "Compound Crank (Torsion Beam)" -> "Compound Crank"
    "Torsion Beam" -> "Compound Crank"
    "Semi-independent" -> "Compound Crank"
    "Semi-Independent Torsion Beam" -> "Compound Crank"
    "Leaf" -> "Multi-Leaf"
    "Short And Long Arm" -> "Short/Long Arm"
    "Trailing arm" -> "Trailing Arm"
    _ -> c
  end
end
```

```elixir
to_cat = ["Drivetrain", "Body Style", "Engine Configuration", "Engine Class",
  "Front Wheel Material", "Air Bag-Frontal-Driver", "Air Bag-Frontal-Passenger", 
  "Air Bag-Passenger Switch (On/Off)", "Air Bag-Side Body-Front", "Air Bag-Side Body-Rear",
  "Air Bag-Side Head-Front", "Air Bag-Side Head-Rear", "Brakes-ABS",
  "Child Safety Rear Door Locks", "Daytime Running Lights", "Traction Control",
  "Night Vision", "Rollover Protection Bars", "Fog Lamps", "Parking Aid", "Tire Pressure Monitor",
  "Back-Up Camera", "Stability Control"]
```

```elixir
df2 = df1 |> DF.mutate_with(
  %{"Fuel System" => df1["Fuel System"] |> S.transform(&(fuel_system_map.(&1))) 
    |> S.cast(:category),
  "Steering Type" => df1["Steering Type"] |> S.transform(&(steering_type_map.(&1))) 
    |> S.cast(:category),
  "Suspension Type - Front" => df1["Suspension Type - Front"] 
    |> S.transform(&(suspension_front_map.(&1))) |> S.cast(:category),
  "Suspension Type - Rear" => df1["Suspension Type - Rear"] 
    |> S.transform(&(suspension_rear_map.(&1))) |> S.cast(:category),
  "Year" => df1["Year"] 
    |> S.transform(&(suspension_rear_map.(&1))) |> S.cast(:integer) 
      |> S.cast(:string) |> S.cast(:category),
  }
) |> DF.mutate_with(fn ldf ->
  to_cat
  |> Enum.map(&{String.to_atom(&1), S.cast(ldf[&1], :category)})
  |> Map.new()
  end)
```

```elixir
df2 |> DF.describe()
```

## 3. Data Visualisation

In the section, I will focus on the relationships between explanatory variables and the response variable `MSRP`. Because of a large number of variables, I will only demonstrate some of them.

```elixir
VegaLite.new(width: 600, height: 400, title: "MSRP")
|> VegaLite.data_from_values(df2, only: ["MSRP"])
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "MSRP", type: :quantitative)
|> VegaLite.encode(:y, aggregate: :count)
```

The distribution of `MSRP` is skewed to right, which is a problem for certain kinds of models (such as Lasso Regression), so for the modelling, I will take log to make it close to normal distribution.

Below are the relationships between numerical variables and `MSRP`.

It is obvious that `Base Curb Weight (lbs)`, `Width`, `Max w/o mirrors (in)`, and `EPA Fuel Economy Est - City (MPG)` have correlations with `MSRP`, the first two have the positive one while the latter has the negative one. Besides, as `Width`, `Max w/o mirrors (in)` increases, the values of `MSRP` spread out, on the other hand, as `EPA Fuel Economy Est - City (MPG)` increases, the values of `MSRP` spread out. In fact, this is a common effect in this dataset, I think it is because some specs are more popular, many manufacturers produce cars based on similar models (with similar specs), but they have different pricing strategies, making the tendency spread out. A good example is the plot of `MSRP` against `Passenger Capacity`, the most common specs (from 2 to 5 seats) have the most diverse prices. I believe that is the reason resulting for the negative relationship between `EPA Fuel Economy Est - City (MPG)` and `MSRP`, at first it is counterintuitive since it means that the more fuel-efficient car is cheaper, but if taking the reasoning above into account, it would make sense.

[4] EPA Fuel Economy Est - City (MPG): https://fueleconomy.gov/feg/label/learn-more-gasoline-label.shtml

```elixir
VegaLite.new(width: 600, height: 400, title: "MSRP vs. Passenger Capacity")
|> VegaLite.data_from_values(df2, only: ["Passenger Capacity", "MSRP"])
|> VegaLite.mark(:point)
|> VegaLite.encode_field(:x, "Passenger Capacity", type: :quantitative)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 600, height: 400, title: "MSRP vs. Base Curb Weight (lbs)")
|> VegaLite.data_from_values(df2, only: ["Base Curb Weight (lbs)", "MSRP"])
|> VegaLite.mark(:point)
|> VegaLite.encode_field(:x, "Base Curb Weight (lbs)", type: :quantitative)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 600, height: 400, title: "MSRP vs. Width, Max w/o mirrors (in)")
|> VegaLite.data_from_values(df2, only: ["Width, Max w/o mirrors (in)", "MSRP"])
|> VegaLite.mark(:point)
|> VegaLite.encode_field(:x, "Width, Max w/o mirrors (in)", type: :quantitative)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 600, height: 400, title: "MSRP vs. EPA Fuel Economy Est - City (MPG)")
|> VegaLite.data_from_values(df2, only: ["EPA Fuel Economy Est - City (MPG)", "MSRP"])
|> VegaLite.mark(:point)
|> VegaLite.encode_field(:x, "EPA Fuel Economy Est - City (MPG)", type: :quantitative)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

In the plot here, there are positive relationships between `MSRP` and `Net Horsepower`, `Net Torque`, `Displacement (cc)`, and `Rear Wheel Size`, and also as the values increase, the price spread out, reflecting the diverse pricing strategies in the market. One thing interesting is that the relationships between `MSRP` and `Net Horsepower RPM` and `Net Torque RPM` are not obvious even though the clear relationships between `MSRP` and `Net Horsepower` and `Net Torque`.

```elixir
VegaLite.new(width: 600, height: 400, title: "MSRP vs. Net Horsepower")
|> VegaLite.data_from_values(df2, only: ["Net Horsepower", "MSRP"])
|> VegaLite.mark(:point)
|> VegaLite.encode_field(:x, "Net Horsepower", type: :quantitative)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 600, height: 400, title: "MSRP vs. Net Horsepower RPM")
|> VegaLite.data_from_values(df2, only: ["Net Horsepower RPM", "MSRP"])
|> VegaLite.mark(:point)
|> VegaLite.encode_field(:x, "Net Horsepower RPM", type: :quantitative)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 600, height: 400, title: "MSRP vs. Net Torque")
|> VegaLite.data_from_values(df2, only: ["Net Torque", "MSRP"])
|> VegaLite.mark(:point)
|> VegaLite.encode_field(:x, "Net Torque", type: :quantitative)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 600, height: 400, title: "MSRP vs. Net Torque RPM")
|> VegaLite.data_from_values(df2, only: ["Net Torque RPM", "MSRP"])
|> VegaLite.mark(:point)
|> VegaLite.encode_field(:x, "Net Torque RPM", type: :quantitative)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 600, height: 400, title: "MSRP vs. Displacement (cc)")
|> VegaLite.data_from_values(df2, only: ["Displacement (cc)", "MSRP"])
|> VegaLite.mark(:point)
|> VegaLite.encode_field(:x, "Displacement (cc)", type: :quantitative)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 600, height: 400, title: "MSRP vs. Rear Wheel Size")
|> VegaLite.data_from_values(df2, only: ["Rear Wheel Size", "MSRP"])
|> VegaLite.mark(:point)
|> VegaLite.encode_field(:x, "Rear Wheel Size", type: :quantitative)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 400, height: 200, title: "MSRP vs. Fuel System")
|> VegaLite.data_from_values(df2, only: ["Fuel System", "MSRP"])
|> VegaLite.mark(:boxplot)
|> VegaLite.encode_field(:x, "Fuel System", type: :nominal)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 400, height: 200, title: "MSRP vs. Steering Type")
|> VegaLite.data_from_values(df2, only: ["Steering Type", "MSRP"])
|> VegaLite.mark(:boxplot)
|> VegaLite.encode_field(:x, "Steering Type", type: :nominal)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 400, height: 200, title: "MSRP vs. Suspension Type - Front")
|> VegaLite.data_from_values(df2, only: ["Suspension Type - Front", "MSRP"])
|> VegaLite.mark(:boxplot)
|> VegaLite.encode_field(:x, "Suspension Type - Front", type: :nominal)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 400, height: 200, title: "MSRP vs. Night Vision")
|> VegaLite.data_from_values(df2, only: ["Night Vision", "MSRP"])
|> VegaLite.mark(:boxplot)
|> VegaLite.encode_field(:x, "Night Vision", type: :nominal)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 400, height: 200, title: "MSRP vs. Child Safety Rear Door Locks")
|> VegaLite.data_from_values(df2, only: ["Child Safety Rear Door Locks", "MSRP"])
|> VegaLite.mark(:boxplot)
|> VegaLite.encode_field(:x, "Child Safety Rear Door Locks", type: :nominal)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

```elixir
VegaLite.new(width: 400, height: 200, title: "MSRP vs. Year")
|> VegaLite.data_from_values(df2, only: ["Year", "MSRP"])
|> VegaLite.mark(:boxplot)
|> VegaLite.encode_field(:x, "Year", type: :nominal)
|> VegaLite.encode_field(:y, "MSRP", type: :quantitative)
```

## 4. Feature Engineering

In this part, I will transform the response variable `MSRP` to log scale for better performance mentioned in the last section. Then, I will replace empty categorical values with "Missing" and encode categorical variables with one-hot encoding. Last, I will split the data into three parts, training data, validating data, and testing data.

```elixir
df2 
|> DF.rename_with(&(String.replace(&1, " ", "_"))) # concatenate the string
```

```elixir
df_Y = df2 |> DF.pull("MSRP")
df_X = df2 |> DF.discard("MSRP")
```

```elixir
df_num = df_X |> DF.select(fn _name, type -> type != :category end) 
  |> DF.mutate_with(
    fn ldf ->
      for col_name <- DF.names(ldf) do
        {col_name, S.cast(ldf[col_name], :f64) |> S.fill_missing(:nan)}
      end
    end
  ) 
```

```elixir
df_cat = df_X |> DF.mutate_with(fn ldf ->
  ["Fuel System", "Steering Type", 
  "Suspension Type - Front", "Suspension Type - Rear", "Year" | to_cat]
  |> Enum.map(&{String.to_atom(&1), S.fill_missing(ldf[&1], "Missing")})
  |> Map.new()
  end) |> DF.dummies(fn _name, type -> type == :category end)
```

```elixir
df_X1 = DF.concat_columns(df_num, df_cat)
```

```elixir
x_tensor = Nx.stack(df_X1, axis: 1)
y_tensor = Nx.stack(df_Y, axis: 1)
```

```elixir
key = Nx.Random.key(42)
n_samples_1 = Nx.axis_size(x_tensor, 0)
train_size_1 = floor(n_samples_1 * 0.8)

# Create shuffled indices
indices_1 = Nx.iota({n_samples_1})
{shuffled_indices_1, _} = Nx.Random.shuffle(key, indices_1)

train_idx_1 = shuffled_indices_1[0..(train_size_1 - 1)]
test_idx_1 = shuffled_indices_1[train_size_1..-1//1]

x_train_1 = Nx.take(x_tensor, train_idx_1)
x_test = Nx.take(x_tensor, test_idx_1)
y_train_1 = Nx.take(y_tensor, train_idx_1)
y_test = Nx.take(y_tensor, test_idx_1)

n_samples_2 = Nx.axis_size(x_train_1, 0)
train_size_2 = floor(n_samples_2 * 0.8)

indices_2 = Nx.iota({n_samples_2})
{shuffled_indices_2, _} = Nx.Random.shuffle(key, indices_2)

train_idx_2 = shuffled_indices_2[0..(train_size_2 - 1)]
test_idx_2 = shuffled_indices_2[train_size_2..-1//1]

x_train = Nx.take(x_train_1, train_idx_2)
x_val = Nx.take(x_train_1, test_idx_2)
y_train = Nx.take(y_train_1, train_idx_2)
y_val = Nx.take(y_train_1, test_idx_2)
```
